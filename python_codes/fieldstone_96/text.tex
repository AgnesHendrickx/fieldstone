

Facts about planet Mars\footnote{\url{https://en.wikipedia.org/wiki/Mars}}:
\begin{itemize}
\item average radius $R=3389.5 \pm 0.2 \si{\km}$
\item equatorial radius $3396.2 \pm 0.1 \si{\km}$
\item polar radius $3376.2 \pm 0.1 \si{\km}$
\item volume $1.6318 \cdot 10^{20} \si{\cubic\metre}$
\item mass $6.4171 \cdot 10^{23}\si{\kilo\gram}$
\item mean density $\langle\rho\rangle= 3934\si{\kilo\gram\per\cubic\meter}$
\item moment of inertia $I=0.3644 \pm 0.0005$
\item surface gravity $g=3.72076 \si{\metre\per\square\second}$
\end{itemize}

The surface gravity can be obtained with 
\[
g_{surf}=\frac{{\cal G} M}{R^2} 
=\frac{6.67430 \cdot 10^{-11} \; 6.4171 \cdot 10^{23} }{(3.3895\cdot 10^6)^2}
\simeq 3.727977
\]

The internal structure of the planet is not settled although 
it is now widely accepted that the planet has a core. 

B. Steinberger was kind enough to communicate to us the density and viscosity 
profiles used in Steinverger \etal (2010) \cite{stwt10} \footnote{Files sent to us 
we slightly altered for the purpose of this work. The density profile was missing 
the 50km near the center of the planet so padding was used. The viscosity profile 
starts below the moho at 50\si{\km} and stopped at the cmb. }:

\begin{center}
\includegraphics[width=7cm]{python_codes/fieldstone_96/data/rho1}
\includegraphics[width=7cm]{python_codes/fieldstone_96/data/eta1}\\
\includegraphics[width=7cm]{python_codes/fieldstone_96/data/rho2}
\includegraphics[width=7cm]{python_codes/fieldstone_96/data/eta2}\\
{\captionfont Data curtesy of B. Steinberger, from \cite{stwt10}} \\
{\tiny {\color{gray} in python\_codes/fieldstone\_96/data/}}
\end{center}


\begin{center}
\includegraphics[width=5.7cm]{python_codes/fieldstone_96/images/stwt10_b}
\includegraphics[width=5.7cm]{python_codes/fieldstone_96/images/stwt10_c}
\includegraphics[width=5.7cm]{python_codes/fieldstone_96/images/stwt10_d}\\
{\captionfont Taken from Steinverger \etal (2010) \cite{stwt10}}
\end{center}

In table 1 of Steinberger \etal \cite{stwt10}: crust thickness is set to 50km. The core radius is set 
to 1389.5km. However in the data set we were sent it seems that the cmb is at 1422\si{\km}
radius.
To simplify things we take $R=3389\si{\km}$ and $R_{cmb}=1422\si{\km}$ in the code.

There are three python files in this \stone:
\begin{itemize}
\item {\pythonfile parameters.py}: the main physical and geometrical parameters are defined in it;
\item {\pythonfile generate\_nodes.py}: this code generates the two files  {\sl mypoints} and {\sl mysegments}
which will be first concatenated into {\sl mesh.poly} and then passed to the Triangle mesher. 
The mesher then returns {\sl mesh.1.node} and {\sl mesh.1.ele}.  
\item {\pythonfile stone.py} This is the 'real' code: the above mentioned files are read in and are used to 
build the mesh. Density and viscosity profile datasets are read in so that viscosity, density and 
gravity acceleration can then be assigned to elements/nodes/quadrature points. Boundary conditions 
are set up, the FEM is built, and the system solved. The pressure at the surface of the planet is 
normalised to zero average. Results are then exported to ascii and vtu file(s).
\end{itemize}
In order to run the code, simply make use of the provided script {\shellscriptfile run\_script}. 
In it the call to the Triangle mesher is carried out:
\begin{verbatim}
../../../../triangle/triangle   -q -j -O -a4000000000 -o2 -pc  mesh.poly
\end{verbatim}
The number following the {\tt -a} option is the maximum size of an element. This controls the 
average size of the generated elements inside the domain. Decreasing this number automatically 
generates more elements, i.e. a higher resolution. 

\begin{center}
\input{tikz/tikz_axi}
\end{center}

\begin{center}
\includegraphics[width=7cm]{python_codes/fieldstone_96/images/notes1}\\
\includegraphics[width=9cm]{python_codes/fieldstone_96/images/notes2}
\end{center}

Given the symmetry of the problem any term containing $\partial_\theta$ or $\upnu_\theta$ is zero.
The strain rate tensor given in Section~\ref{ss:srcc} then simplifies to:

\begin{eqnarray}
\dot\varepsilon_{rr} 
&=& \frac{\partial \upnu_r}{\partial r} \nn\\
\dot\varepsilon_{\theta\theta}  &=& \frac{\upnu_r}{r} \nn\\
\dot\varepsilon_{\theta r} = \dot\varepsilon_{r\theta}  &=& 0 \nn\\
\dot\varepsilon_{zz} &=& \frac{\partial \upnu_z}{\partial z} \nn\\
\dot{\varepsilon}_{rz} = \dot{\varepsilon}_{zr} 
&=& \frac{1}{2}\left( \frac{\partial \upnu_r}{\partial z} + \frac{\partial \upnu_z}{\partial r} \right) \nn\\
\dot{\varepsilon}_{\theta z} = \dot{\varepsilon}_{z \theta} &=& 0 \nn
\end{eqnarray}
Note that the term $\dot\varepsilon_{\theta\theta} $ is not zero!
The deviatoric stress tensor ${\bm \tau}=2\eta \dot{\bm \varepsilon}$ can be computed
as well as the full stress tensor ${\bm \sigma}=-p {\bm 1} + {\bm \tau}$. 

\begin{center}
\includegraphics[width=6cm]{python_codes/fieldstone_96/images/rho}
\includegraphics[width=6cm]{python_codes/fieldstone_96/images/eta}
\includegraphics[width=6cm]{python_codes/fieldstone_96/images/mesh}
\end{center}

We wish to compute the stress at the surface. At any given point the surface is characterised
by its (local) normal vector $\vec{n}$. The traction at that point will then be $\vec{t}={\bm \sigma}\cdot \vec{n}$.
\begin{eqnarray}
\vec{t} &=& 
\left(
\begin{array}{ccc}
\sigma_{rr} & \sigma_{r \theta} & \sigma_{rz} \\
\sigma_{\theta r} & \sigma_{\theta\theta} & \sigma_{\theta z} \\
\sigma_{z r} & \sigma_{z \theta} & \sigma_{zz} 
\end{array}
\right)
\cdot 
\left(
\begin{array}{c}
n_r \\ n_\theta \\ n_z
\end{array}
\right)  \\
&=&
\left[
- p {\bm 1} + 2 \eta 
\left(
\begin{array}{ccc}
\dot{\varepsilon}_{rr}       & \dot{\varepsilon}_{r \theta}     & \dot{\varepsilon}_{rz} \\
\dot{\varepsilon}_{\theta r} & \dot{\varepsilon}_{\theta\theta} & \dot{\varepsilon}_{\theta z} \\
\dot{\varepsilon}_{z r}      & \dot{\varepsilon}_{z \theta}     & \dot{\varepsilon}_{zz} 
\end{array}
\right)
\right]
\cdot 
\left(
\begin{array}{c}
n_r \\ 0 \\ n_z
\end{array}
\right) \\
&=&
\left[
- p {\bm 1} + 2 \eta 
\left(
\begin{array}{ccc}
\dot{\varepsilon}_{rr}       & 0     & \dot{\varepsilon}_{rz} \\
0  & \dot{\varepsilon}_{\theta\theta} & 0 \\
\dot{\varepsilon}_{z r}      & 0     & \dot{\varepsilon}_{zz} 
\end{array}
\right)
\right]
\cdot 
\left(
\begin{array}{c}
n_r \\ 0 \\ n_z
\end{array}
\right) \\
&=& 
\left(
\begin{array}{c}
-p n_r  + 2 \eta ( \dot{\varepsilon}_{rr} n_r + \dot{\varepsilon}_{rz} n_z) \\
0 \\
-p n_z + 2 \eta (\dot{\varepsilon}_{z r} n_r +  \dot{\varepsilon}_{zz}  n_z )
\end{array}
\right) 
\end{eqnarray}

The radial component of the traction is also computed as $t_r=\vec{t}\cdot \vec{n}$.
Results are exported in the {\filenamefont surface\_traction.ascii} file.


 
%--------------------------------------------------
\subsubsection*{Gravity calculations}

This is an axisymmetric problem so the mesh is generated for a single value of the cylindrical 
coordinates $\theta$ angle. 
This makes gravity calculations a bit more difficult because each triangle of the mesh corresponds
in 3D to a ring of matter with this triangular cross section. 
I have therefore chosen to chunk this ring in {\tt nel\_phi} bits. Each bit has a given volume and therefore
mass, and having computed its center its generated gravity field can be added. 
The volume of such a block is $\iiint_{block} r dr d\theta dz =\iint_\triangle rdrdz \cdot \int d\theta$.  
The first integral is carried out for each triangle and the result is stored in the {\tt arear} array. 







TODO: elliptic blob
